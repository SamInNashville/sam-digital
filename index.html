<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sam Digital — Nashville Digital Services</title>
<meta name="description" content="Sam Digital is a Nashville-based digital services agency specializing in software development, research, technical writing, and automation." />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  /* Reset & base */
  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial;
    color:#e6eef8; background:#0b1020; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    overflow:hidden; /* we control scrolling in the scroller */
  }
  a{color:inherit}

  /* Top nav (transparent over scene) */
  nav{position:fixed;left:0;right:0;top:0;height:64px;display:flex;align-items:center;justify-content:space-between;padding:0 24px;z-index:40;pointer-events:auto}
  .nav-inner{background:linear-gradient(180deg, rgba(10,12,18,0.45), rgba(10,12,18,0.15));backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border-radius:12px;padding:10px 14px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:18px;align-items:center}
  .logo{font-weight:800;letter-spacing:-0.02em;color:#fff}
  .nav-links{display:flex;gap:12px}
  .nav-links a{font-size:0.9rem;color:rgba(230,238,248,0.8);text-decoration:none;padding:6px 10px;border-radius:8px}
  .nav-links a:hover{background:rgba(255,255,255,0.03)}
  .nav-links a.active{background:rgba(159,211,255,0.12);color:#fff}

  /* Horizontal scroller - each section is full viewport width and height */
  .scroller{
    position:fixed;inset:0;display:flex;flex-direction:row;overflow-x:auto;overflow-y:hidden;scroll-snap-type:x mandatory;-webkit-overflow-scrolling:touch;scroll-behavior:smooth;will-change:transform;z-index:20;
  }
  .panel{min-width:100vw;height:100vh;flex:0 0 100vw;display:flex;align-items:center;justify-content:center;padding:88px 48px;scroll-snap-align:center;}
  .panel-inner{max-width:980px}

  /* Vertical fallback for narrow screens */
  @media (max-width:720px){
    body{overflow:auto}
    .scroller{position:relative;display:block;overflow:auto;height:auto;flex-direction:column;scroll-snap-type:y mandatory}
    .panel{min-width:unset;flex:0 0 auto;height:auto;padding:88px 20px;scroll-snap-align:center}
  }

  /* Content styles (keeps existing content) */
  h1{font-size:clamp(28px,6vw,56px);line-height:1.03;margin-bottom:12px;color:#f6fbff}
  h2{font-size:28px;color:#eaf4ff;margin-bottom:14px}
  p{color:rgba(230,238,248,0.85);font-size:16px}
  .badge{display:inline-block;margin-top:14px;padding:8px 14px;border-radius:999px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.03);font-weight:600;font-size:12px}

  /* Services grid */
  .services-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:18px;margin-top:18px}
  .service-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:18px;border-radius:12px}
  .service-card h3{margin-bottom:6px}
  @media (max-width:720px){.services-grid{grid-template-columns:1fr}}

  /* About points */
  .about-points{display:flex;gap:16px;margin-top:12px}
  .about-point{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:10px}
  @media (max-width:720px){.about-points{flex-direction:column}}

  /* Contact box */
  .contact-box{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:20px;border-radius:12px;text-align:center}
  .contact-box a.email{color:#9fd3ff;font-weight:700}

  /* Footer */
  footer{padding:28px 20px;text-align:center;color:rgba(200,210,225,0.6)}

  /* Small helper for anchors (keyboard focus) */
  a:focus{outline:2px solid rgba(159,211,255,0.25);outline-offset:4px;border-radius:6px}

  /* Decorative: subtle vignette */
  .vignette{position:fixed;pointer-events:none;inset:0;z-index:35;background:radial-gradient(60% 40% at 50% 40%, rgba(0,0,0,0) 0%, rgba(2,6,10,0.12) 60%, rgba(2,6,10,0.34) 100%);mix-blend-mode:multiply}

  /* PERFORMANCE HINTS */
  .parallax-layer{position:fixed;inset:0;width:100%;height:100%;pointer-events:none;will-change:transform;transform:translateZ(0)}

</style>
</head>
<body>

<nav>
  <div class="nav-inner">
    <div class="logo">Sam Digital</div>
    <div class="nav-links">
      <a href="#home">Home</a>
      <a href="#services">Services</a>
      <a href="#process">How It Works</a>
      <a href="#about">About</a>
      <a href="#contact">Contact</a>
    </div>
  </div>
</nav>

<!-- Parallax background replaced with performant canvas particle system -->
<div class="parallax-layer" aria-hidden="true">
  <canvas id="bg-canvas" width="1600" height="900" style="width:100%;height:100%;display:block"></canvas>
  <!-- Gradient mesh overlay using absolutely positioned divs for subtle color blobs -->
  <div id="gradients" aria-hidden="true" style="position:absolute;inset:0;pointer-events:none;mix-blend-mode:screen;opacity:0.9">
    <div class="blob" style="position:absolute;width:800px;height:800px;border-radius:50%;left:-10%;top:10%;background:radial-gradient(circle at 30% 30%, rgba(63,132,255,0.18), rgba(45,58,120,0.06) 40%, transparent 60%);filter:blur(140px);transform:translate3d(0,0,0);"></div>
    <div class="blob" style="position:absolute;width:900px;height:900px;border-radius:50%;left:40%;top:-20%;background:radial-gradient(circle at 60% 40%, rgba(142,86,255,0.14), rgba(45,24,90,0.04) 40%, transparent 60%);filter:blur(160px);transform:translate3d(0,0,0);"></div>
    <div class="blob" style="position:absolute;width:700px;height:700px;border-radius:50%;left:75%;top:30%;background:radial-gradient(circle at 40% 60%, rgba(255,190,80,0.08), rgba(60,34,12,0.02) 40%, transparent 60%);filter:blur(120px);transform:translate3d(0,0,0);"></div>
  </div>
</div>

<!-- Vignette -->
<div class="vignette"></div>

<script>
// Canvas particle background (replaces SVG scene and old parallax)
(function canvasParticles(){
  const canvas = document.getElementById('bg-canvas');
  const gradContainer = document.getElementById('gradients');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');

  // Resize handling
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Particle system parameters
  const palette = [ '#66d1ff', '#4bd3c7', '#a48dff', '#8fb0ff', '#ffc765' ]; // blues, teal, purple, warm accent
  const bgColor = '#0a0a1a';
  const numParticles = Math.max(80, Math.round((window.innerWidth * window.innerHeight) / 4500)); // scale with area
  const particles = [];
  const depths = [0.35, 0.6, 0.9, 1.2]; // different layers speeds

  // create particles
  function initParticles(){
    particles.length = 0;
    for(let i=0;i<numParticles;i++){
      const depth = depths[Math.floor(Math.random()*depths.length)];
      const size = Math.random()*3 + 1; // 1-4 px
      const x = Math.random()*window.innerWidth;
      const y = Math.random()*window.innerHeight;
      const vx = (Math.random()*0.4 - 0.2) * (1/depth); // slower for deeper
      const vy = (Math.random()*0.2 - 0.1) * (1/depth);
      const color = palette[Math.floor(Math.random()*palette.length)];
      const opacity = 0.2 + Math.random()*0.8; // vary opacity
      const star = Math.random() < 0.06; // some brighter stars
      particles.push({x,y,vx,vy,size,depth,color,opacity,star});
    }
  }
  initParticles();

  // Interaction state
  let pointer = {x:-9999,y:-9999,down:false};
  function updatePointer(e){
    const rect = canvas.getBoundingClientRect();
    pointer.x = (e.touches ? e.touches[0].clientX : e.clientX) || pointer.x;
    pointer.y = (e.touches ? e.touches[0].clientY : e.clientY) || pointer.y;
  }
  window.addEventListener('pointermove', updatePointer, {passive:true});
  window.addEventListener('touchmove', updatePointer, {passive:true});
  window.addEventListener('pointerleave', ()=>{ pointer.x=-9999; pointer.y=-9999; }, {passive:true});

  // Parallax offsets based on horizontal scroll
  let parallaxOffset = 0; // 0..1 based on scroller
  const scroller = document.getElementById('scroller');
  function updateParallax(){
    if(!scroller) return;
    const maxScroll = Math.max(1, scroller.scrollWidth - scroller.clientWidth);
    parallaxOffset = scroller.scrollLeft / maxScroll;
  }
  if(scroller){ scroller.addEventListener('scroll', ()=>{ requestAnimationFrame(updateParallax); }); updateParallax(); }

  // Animation loop
  let last = performance.now();
  function tick(now){
    const dt = Math.min(40, now - last);
    last = now;
    // clear
    ctx.fillStyle = bgColor;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw connecting lines subtly
    ctx.lineWidth = 0.6;
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      // update position — skip normal movement for comet-disrupted particles
      const parallaxX = (parallaxOffset - 0.5) * (30 * (1/p.depth));
      if(p.homeX === undefined){
        p.x += p.vx * (dt/16);
        p.y += p.vy * (dt/16);
        // gentle noise movement
        p.x += Math.sin((now/4000 + i) * 0.7) * 0.02;
        p.y += Math.cos((now/3000 + i) * 0.5) * 0.01;
      } else {
        // disrupted: spring-back controls movement via vx/vy
        p.x += p.vx * (dt/16);
        p.y += p.vy * (dt/16);
      }
      // wrap around edges (skip disrupted particles — let spring handle them)
      if(p.homeX === undefined){
        if(p.x < -20) p.x = window.innerWidth + 20;
        if(p.x > window.innerWidth + 20) p.x = -20;
        if(p.y < -20) p.y = window.innerHeight + 20;
        if(p.y > window.innerHeight + 20) p.y = -20;
      }
    }

    // Interaction: repel/attract (skip comet-disrupted particles)
    const influenceRadius = 120;
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      if(p.homeX !== undefined) continue;
      const dx = pointer.x - p.x;
      const dy = pointer.y - p.y;
      const dist2 = dx*dx + dy*dy;
      if(dist2 < influenceRadius*influenceRadius){
        const dist = Math.sqrt(dist2) || 1;
        const force = (1 - dist / influenceRadius) * 0.6; // subtle
        // mix attract and repel based on depth
        const sign = p.depth > 0.9 ? -1 : 1; // closer layers repel, deeper attract
        p.x += -dx/dist * force * sign;
        p.y += -dy/dist * force * sign * 0.6;
      }
    }

    // draw connections
    for(let i=0;i<particles.length;i++){
      const a = particles[i];
      for(let j=i+1;j<particles.length;j++){
        const b = particles[j];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const d2 = dx*dx + dy*dy;
        if(d2 < 16000){ // within ~126px
          const alpha = Math.max(0, 0.12 - d2 / 16000 * 0.12) * (1/( (a.depth+b.depth)/2 ));
          ctx.strokeStyle = 'rgba(140,170,255,'+ (alpha*0.9) +')';
          ctx.beginPath();
          ctx.moveTo(a.x + (parallaxOffset-0.5) * (10*(1/a.depth)), a.y);
          ctx.lineTo(b.x + (parallaxOffset-0.5) * (10*(1/b.depth)), b.y);
          ctx.stroke();
        }
      }
    }

    // Update & draw comet
    updateComet(dt);
    springBack(dt);
    drawComet();

    // draw particles on top of lines
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      const px = p.x + parallaxXFor(p.depth);
      // glow
      if(p.star){
        ctx.beginPath();
        const grd = ctx.createRadialGradient(px, p.y, 0, px, p.y, p.size*6);
        grd.addColorStop(0, rgba(p.color, p.opacity * 1.0));
        grd.addColorStop(0.6, rgba(p.color, p.opacity * 0.18));
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(px - p.size*6, p.y - p.size*6, p.size*12, p.size*12);
      }
      // core
      ctx.beginPath();
      ctx.fillStyle = rgba(p.color, p.opacity);
      ctx.arc(px, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    }

    requestAnimationFrame(tick);
  }

  function parallaxXFor(depth){
    return (parallaxOffset - 0.5) * (40 * (1/depth));
  }

  function rgba(hex, a){
    const c = hex.replace('#','');
    const r = parseInt(c.substring(0,2),16);
    const g = parseInt(c.substring(2,4),16);
    const b = parseInt(c.substring(4,6),16);
    return 'rgba('+r+','+g+','+b+','+a+')';
  }

  // --- Comet system ---
  // Sporadic comet every 30-60s that disrupts nearby particles
  let comet = null;

  function spawnComet(){
    const w = window.innerWidth;
    const h = window.innerHeight;
    // Pick a random edge to enter from: 0=left, 1=right, 2=top, 3=bottom
    const edge = Math.floor(Math.random() * 4);
    let startX, startY;
    if(edge === 0){      startX = -40;        startY = Math.random() * h; }
    else if(edge === 1){ startX = w + 40;     startY = Math.random() * h; }
    else if(edge === 2){ startX = Math.random() * w; startY = -40; }
    else {               startX = Math.random() * w; startY = h + 40; }
    // Exit toward a random point on the opposite-ish side
    const exitEdge = (edge + 2 + Math.floor(Math.random() * 2 - 0.5)) % 4;
    let endX, endY;
    if(exitEdge === 0){      endX = -40;        endY = Math.random() * h; }
    else if(exitEdge === 1){ endX = w + 40;     endY = Math.random() * h; }
    else if(exitEdge === 2){ endX = Math.random() * w; endY = -40; }
    else {                   endX = Math.random() * w; endY = h + 40; }
    const dx = endX - startX;
    const dy = endY - startY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const speed = Math.max(w, h) / (1.2 + Math.random() * 0.6); // cross in ~1.2-1.8s
    comet = {
      x: startX, y: startY,
      vx: (dx / dist) * speed,
      vy: (dy / dist) * speed,
      life: 0,
      maxLife: dist / speed,
      trail: [],
      radius: 140 // disruption radius
    };
  }

  function scheduleComet(){
    const delay = (30 + Math.random() * 30) * 1000;
    setTimeout(()=>{ spawnComet(); scheduleComet(); }, delay);
  }
  // first comet after 8-15s so it's a surprise
  setTimeout(()=>{ spawnComet(); scheduleComet(); }, 8000 + Math.random() * 7000);

  function updateComet(dt){
    if(!comet) return;
    const s = dt / 1000;
    comet.x += comet.vx * s;
    comet.y += comet.vy * s;
    comet.life += s;
    // store trail point
    comet.trail.push({x: comet.x, y: comet.y, age: 0});
    // age trail points
    for(let i = comet.trail.length - 1; i >= 0; i--){
      comet.trail[i].age += s;
      if(comet.trail[i].age > 0.6) comet.trail.splice(i, 1);
    }
    // disrupt nearby particles — push them away with immediate displacement
    const r2 = comet.radius * comet.radius;
    for(let i = 0; i < particles.length; i++){
      const p = particles[i];
      const dx = p.x - comet.x;
      const dy = p.y - comet.y;
      const d2 = dx*dx + dy*dy;
      if(d2 < r2 && d2 > 1){
        const d = Math.sqrt(d2);
        const force = (1 - d / comet.radius);
        // store home position and original velocity for spring-back
        if(p.homeX === undefined){ p.homeX = p.x; p.homeY = p.y; p.origVx = p.vx; p.origVy = p.vy; p.settleDelay = 0; }
        // subtle position displacement + gentle velocity kick
        const pushX = (dx / d) * force;
        const pushY = (dy / d) * force;
        p.x += pushX * 2;
        p.y += pushY * 2;
        p.vx += pushX * 1.25;
        p.vy += pushY * 1.25;
        p.settleDelay = 0; // reset settle delay — comet is still nearby
      }
    }
    // expire
    if(comet.life > comet.maxLife + 0.3) comet = null;
  }

  function drawComet(){
    if(!comet) return;
    // draw trail
    for(let i = 0; i < comet.trail.length; i++){
      const t = comet.trail[i];
      const alpha = Math.max(0, 1 - t.age / 0.6);
      const size = 2.5 * alpha;
      ctx.beginPath();
      ctx.fillStyle = rgba('#ffeedd', alpha * 0.7);
      ctx.arc(t.x, t.y, size, 0, Math.PI*2);
      ctx.fill();
    }
    // draw head with glow + lens flare
    if(comet.life <= comet.maxLife){
      const cx = comet.x;
      const cy = comet.y;
      // outer glow
      const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 18);
      grd.addColorStop(0, 'rgba(255,240,220,0.9)');
      grd.addColorStop(0.3, 'rgba(255,200,140,0.4)');
      grd.addColorStop(1, 'rgba(255,200,140,0)');
      ctx.beginPath();
      ctx.fillStyle = grd;
      ctx.arc(cx, cy, 18, 0, Math.PI*2);
      ctx.fill();

      // lens flare — horizontal streak
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      const flareGrd = ctx.createLinearGradient(cx - 60, cy, cx + 60, cy);
      flareGrd.addColorStop(0, 'rgba(255,220,180,0)');
      flareGrd.addColorStop(0.3, 'rgba(255,230,200,0.15)');
      flareGrd.addColorStop(0.5, 'rgba(255,245,235,0.3)');
      flareGrd.addColorStop(0.7, 'rgba(255,230,200,0.15)');
      flareGrd.addColorStop(1, 'rgba(255,220,180,0)');
      ctx.fillStyle = flareGrd;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 60, 2.5, 0, 0, Math.PI*2);
      ctx.fill();

      // vertical streak (shorter, dimmer)
      const flareV = ctx.createLinearGradient(cx, cy - 35, cx, cy + 35);
      flareV.addColorStop(0, 'rgba(200,220,255,0)');
      flareV.addColorStop(0.3, 'rgba(200,220,255,0.08)');
      flareV.addColorStop(0.5, 'rgba(230,240,255,0.18)');
      flareV.addColorStop(0.7, 'rgba(200,220,255,0.08)');
      flareV.addColorStop(1, 'rgba(200,220,255,0)');
      ctx.fillStyle = flareV;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 1.5, 35, 0, 0, Math.PI*2);
      ctx.fill();

      // small hexagonal ghost artifacts along the flare
      const ghosts = [{dx: 28, r: 5, a: 0.06}, {dx: -22, r: 3.5, a: 0.04}, {dx: 45, r: 8, a: 0.035}];
      ghosts.forEach(function(g){
        const gx = cx + g.dx;
        const gg = ctx.createRadialGradient(gx, cy, 0, gx, cy, g.r);
        gg.addColorStop(0, 'rgba(180,210,255,' + g.a + ')');
        gg.addColorStop(0.6, 'rgba(160,200,255,' + (g.a * 0.4) + ')');
        gg.addColorStop(1, 'rgba(160,200,255,0)');
        ctx.fillStyle = gg;
        ctx.beginPath();
        ctx.arc(gx, cy, g.r, 0, Math.PI*2);
        ctx.fill();
      });

      ctx.restore();

      // bright core
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,252,245,0.95)';
      ctx.arc(cx, cy, 2.5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Spring-back: wait for comet to pass, then gently return particles home
  function springBack(dt){
    const s = dt / 1000;
    for(let i = 0; i < particles.length; i++){
      const p = particles[i];
      if(p.homeX !== undefined){
        // let particles drift freely for 1s after last comet contact, then settle over ~4s
        p.settleDelay = (p.settleDelay || 0) + s;
        if(p.settleDelay < 1.0){
          // gentle natural damping while drifting
          p.vx *= Math.max(0, 1 - 0.3 * s);
          p.vy *= Math.max(0, 1 - 0.3 * s);
          continue;
        }
        // ease-in the spring strength over 4 seconds (settleDelay 1.0 → 5.0)
        const settleT = Math.min(1, (p.settleDelay - 1.0) / 4.0); // 0→1 over 4s
        const springStr = 0.3 + settleT * 1.2; // ramps from 0.3 to 1.5
        const dampStr = 0.8 + settleT * 1.5; // ramps from 0.8 to 2.3
        const dx = p.homeX - p.x;
        const dy = p.homeY - p.y;
        const d2 = dx*dx + dy*dy;
        if(d2 < 4 && p.settleDelay > 3.0){
          // close enough — snap home and restore normal behavior
          p.x = p.homeX; p.y = p.homeY;
          p.vx = p.origVx; p.vy = p.origVy;
          delete p.homeX; delete p.homeY;
          delete p.origVx; delete p.origVy;
          delete p.settleDelay;
        } else {
          p.vx += dx * springStr * s;
          p.vy += dy * springStr * s;
          // extra damping when close to prevent oscillation
          const closeDamp = d2 < 25 ? 2.0 : 0;
          p.vx *= Math.max(0, 1 - (dampStr + closeDamp) * s);
          p.vy *= Math.max(0, 1 - (dampStr + closeDamp) * s);
        }
      }
    }
  }

  // kick off
  requestAnimationFrame(tick);

  // Re-init on orientation change / resize
  window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ initParticles(); resize(); },300); });

})();
</script>

<!-- Horizontal scroller with panels -->
<div id="scroller" class="scroller" tabindex="0">
  <section class="panel" id="home" aria-label="Home">
    <div class="panel-inner">
      <div style="max-width:760px">
        <div style="font-size:14px;color:rgba(230,238,248,0.7);margin-bottom:8px">Nashville, TN</div>
        <h1>Your Idea, Built Right</h1>
        <p style="font-size:18px;opacity:0.95">Sam Digital turns your ideas into working software — whether it's a quick script, a full application, or getting two systems to finally talk to each other. 40 years of experience, one focused team, no runaround.</p>
        <div class="badge">Fast Delivery · Fixed Quotes · Free Consultation</div>
      </div>
    </div>
  </section>

  <section class="panel" id="services" aria-label="Services">
    <div class="panel-inner">
      <div class="section-label" style="color:#9fd3ff;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;font-size:12px;margin-bottom:8px">What We Do</div>
      <h2>Services</h2>
      <div class="services-grid" style="margin-top:6px">
        <div class="service-card">
          <h3>Software Development</h3>
          <p>Custom scripts, apps, APIs, and integrations in Python, TypeScript, and more. From a quick fix to a full build — most projects delivered same-day or next-day.</p>
        </div>
        <div class="service-card">
          <h3>Research &amp; Analysis</h3>
          <p>Market research, data analysis, and competitive reports — structured, sourced, and ready to act on. Solid evidence for confident decisions.</p>
        </div>
        <div class="service-card">
          <h3>Technical Writing</h3>
          <p>Documentation, how-to guides, and process manuals that your team will actually use. Clear enough that nobody has to ask "how does this work?"</p>
        </div>
        <div class="service-card">
          <h3>Automation</h3>
          <p>If you do it more than twice, we can automate it. Data entry, file processing, email workflows, system integrations — reclaim your time.</p>
        </div>
      </div>
    </div>
  </section>

  <section class="panel" id="process" aria-label="How It Works">
    <div class="panel-inner">
      <div class="section-label" style="color:#9fd3ff;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;font-size:12px;margin-bottom:8px">How It Works</div>
      <h2>Simple Process</h2>
      <div class="about-points">
        <div class="about-point"><h3>1. Tell Us What You Need</h3><p>Describe the problem — it doesn't have to be technical. We'll ask the right questions and figure out the best approach together. Free, no commitment.</p></div>
        <div class="about-point"><h3>2. Get a Fixed Quote</h3><p>Within 24 hours, you'll have a clear scope, a fixed price, and a timeline. No hourly billing, no open-ended estimates. You know exactly what you're getting.</p></div>
        <div class="about-point"><h3>3. We Build, You Review</h3><p>We deliver the work, you review it, we refine until it's right. You only pay the balance when you're satisfied. That's the whole process.</p></div>
      </div>
    </div>
  </section>

  <section class="panel" id="about" aria-label="About">
    <div class="panel-inner">
      <div class="section-label" style="color:#9fd3ff;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;font-size:12px;margin-bottom:8px">Who We Are</div>
      <h2>About</h2>
      <p style="max-width:760px;margin-bottom:14px">Sam Digital is a Nashville-based digital services shop backed by 40 years of software development experience — from video games to enterprise systems to AI. We've seen every kind of project and we bring that depth to every job, big or small.</p>
      <div class="about-points">
        <div class="about-point"><h3>You Talk to the Builder</h3><p>No account managers, no middlemen. The person you email is the person writing your code.</p></div>
        <div class="about-point"><h3>40 Years of Experience</h3><p>Games, corporate software, startups, AI integration. We've built it all and we're still learning every day.</p></div>
        <div class="about-point"><h3>Honest Estimates</h3><p>Fixed prices, quoted upfront. We'd rather earn your trust on a small job and grow from there.</p></div>
      </div>
    </div>
  </section>

  <section class="panel" id="contact" aria-label="Contact">
    <div class="panel-inner">
      <div class="section-label" style="color:#9fd3ff;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;font-size:12px;margin-bottom:8px">Let's Talk</div>
      <h2>Start a Conversation</h2>
      <div class="contact-box" style="margin-top:12px;max-width:540px">
        <p>Tell us what you're working on. We'll let you know if we can help — and how. No pressure, no pitch, just a straight answer within 24 hours.</p>
        <a class="email" href="mailto:sam-in-nashville@pm.me">sam-in-nashville@pm.me</a>
        <p style="margin-top:12px;font-size:13px;opacity:0.7">&copy; 2026 Sam Digital. Nashville, Tennessee.</p>
      </div>
    </div>
  </section>
</div>

<script>
// Build repeated trees across the width for the SVG trees row (rounded canopies)
(function buildTrees(){
  const svgNS = 'http://www.w3.org/2000/svg';
  const group = document.getElementById('trees-repeat');
  if(!group) return;
  const width = 1600;
  // varying spacing for a more natural rhythm
  const baseSpacing = 70;
  for(let x=0;x<width;x+=baseSpacing + (Math.random()*40 - 10)){
    const g = document.createElementNS(svgNS,'g');
    const jitterY = Math.floor(Math.random()*18 - 6);
    g.setAttribute('transform',`translate(${Math.round(x)},${jitterY})`);

    // trunk
    const trunk = document.createElementNS(svgNS,'rect');
    trunk.setAttribute('x',-3); trunk.setAttribute('y',40); trunk.setAttribute('width',6); trunk.setAttribute('height',18);
    trunk.setAttribute('fill','#2b1b12'); trunk.setAttribute('opacity','0.95');

    // foliage: cluster of overlapping circles/ellipses to form organic canopy
    const canopy = document.createElementNS(svgNS,'g');
    const canopyColors = ['#2f7b49','#2a6b3a','#1f5530'];
    const cx = 0; const cy = 28;
    const sizes = [ {x:-18,y:0,rx:26,ry:20},{x:0,y:-6,rx:32,ry:22},{x:18,y:2,rx:24,ry:18},{x:-6,y:-12,rx:16,ry:12} ];
    sizes.forEach((s,i)=>{
      const c = document.createElementNS(svgNS,'ellipse');
      c.setAttribute('cx', cx + s.x);
      c.setAttribute('cy', cy + s.y);
      c.setAttribute('rx', s.rx);
      c.setAttribute('ry', s.ry);
      c.setAttribute('fill', canopyColors[i % canopyColors.length]);
      c.setAttribute('opacity', 0.98 - (i*0.03));
      canopy.appendChild(c);
    });

    // small highlight overlay to suggest sun on foliage (warm tint)
    const highlight = document.createElementNS(svgNS,'ellipse');
    highlight.setAttribute('cx', -4); highlight.setAttribute('cy', 20); highlight.setAttribute('rx', 14); highlight.setAttribute('ry', 8);
    highlight.setAttribute('fill', 'rgba(255,200,140,0.08)');

    g.appendChild(canopy);
    g.appendChild(highlight);
    g.appendChild(trunk);
    group.appendChild(g);
  }
})();

// Parallax logic: move layers horizontally at different speeds based on scroller scrollLeft
(function parallax(){
  const scroller = document.getElementById('scroller');
  const far = document.getElementById('mountains-far');
  const mid = document.getElementById('mountains-mid');
  const trees = document.getElementById('trees-mid');
  const fg = document.getElementById('foreground');
  if(!scroller || !far) return;

  // helper: set transform with translate3d for GPU
  function setX(el, x){ el.style.transform = `translate3d(${x}px,0,0)` }

  function onScroll(){
    const maxScroll = scroller.scrollWidth - scroller.clientWidth || 1;
    const t = scroller.scrollLeft / maxScroll; // 0..1
    const range = scroller.clientWidth; // rough viewport width
    // translate layers in opposite direction for parallax effect
    setX(far, -t * range * 0.15);
    setX(mid, -t * range * 0.28);
    setX(trees, -t * range * 0.5);
    setX(fg, -t * range * 0.9);
  }

  // throttle with requestAnimationFrame
  let ticking = false;
  scroller.addEventListener('scroll',()=>{ if(!ticking){requestAnimationFrame(()=>{onScroll();ticking=false}); ticking=true;} });
  // initial
  onScroll();

  // keyboard arrows to navigate panels for accessibility
  scroller.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowRight'){ e.preventDefault(); scroller.scrollBy({left:scroller.clientWidth,behavior:'smooth'});} 
    if(e.key==='ArrowLeft'){ e.preventDefault(); scroller.scrollBy({left:-scroller.clientWidth,behavior:'smooth'});} 
    if(e.key==='Home'){ e.preventDefault(); scroller.scrollTo({left:0,behavior:'smooth'});} 
    if(e.key==='End'){ e.preventDefault(); scroller.scrollTo({left:scroller.scrollWidth,behavior:'smooth'});} 
  });

  // anchor links: smooth scroll to panel
  document.querySelectorAll('a[href^="#"]').forEach(a=>{
    a.addEventListener('click', (e)=>{
      const targetId = a.getAttribute('href').slice(1);
      const target = document.getElementById(targetId);
      if(target){ e.preventDefault();
        if(window.matchMedia('(max-width:720px)').matches){ // vertical fallback
          target.scrollIntoView({behavior:'smooth',block:'center'});
        } else {
          const left = target.offsetLeft;
          scroller.scrollTo({left,behavior:'smooth'});
        }
      }
    });
  });

})();

// Active nav link: update as user scrolls between panels
(function activeNav(){
  var scroller = document.getElementById('scroller');
  var navLinks = document.querySelectorAll('.nav-links a[href^="#"]');
  var sections = ['home','services','process','about','contact'];

  function update(){
    var center = scroller.scrollLeft + (scroller.clientWidth / 2);
    var closest = null;
    var closestDist = Infinity;
    sections.forEach(function(id){
      var el = document.getElementById(id);
      if(!el) return;
      var mid = el.offsetLeft + el.clientWidth / 2;
      var d = Math.abs(mid - center);
      if(d < closestDist){ closestDist = d; closest = id; }
    });
    navLinks.forEach(function(a){
      var href = a.getAttribute('href').slice(1);
      if(href === closest){ a.classList.add('active'); }
      else { a.classList.remove('active'); }
    });
  }

  var ticking2 = false;
  scroller.addEventListener('scroll', function(){
    if(!ticking2){ requestAnimationFrame(function(){ update(); ticking2 = false; }); ticking2 = true; }
  });
  update();
})();

// Translate vertical scroll/wheel into horizontal scrolling
(function verticalToHorizontal(){
  const scroller = document.getElementById('scroller');
  if(!scroller) return;
  document.addEventListener('wheel', function(e){
    if(window.matchMedia('(max-width:720px)').matches) return;
    e.preventDefault();
    scroller.scrollBy({left: e.deltaY || e.deltaX, behavior: 'auto'});
  }, {passive: false});
})();

// Ensure scroller snaps to panels after wheel/scroll end
(function snapOnWheelEnd(){
  const scroller = document.getElementById('scroller');
  if(!scroller) return;
  let timeout;
  function snapToNearest(){
    if(window.matchMedia('(max-width:720px)').matches) return;
    const panels = Array.from(scroller.querySelectorAll('.panel'));
    const center = scroller.scrollLeft + (scroller.clientWidth/2);
    let nearest = panels[0]; let dist = Infinity;
    panels.forEach(p=>{
      const c = p.offsetLeft + p.clientWidth/2;
      const d = Math.abs(c-center);
      if(d<dist){dist=d;nearest=p}
    });
    scroller.scrollTo({left: nearest.offsetLeft, behavior:'smooth'});
  }
  ['wheel','touchend','pointerup'].forEach(ev=>{
    scroller.addEventListener(ev, ()=>{
      clearTimeout(timeout);
      timeout = setTimeout(snapToNearest,120);
    });
  });
})();

</script>
</body>
</html>